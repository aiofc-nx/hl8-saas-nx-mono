# åŸºç¡€è®¾æ–½å±‚è®¾è®¡æ–‡æ¡£

> **æ–‡æ¡£ç‰ˆæœ¬**: 1.0.0  
> **åˆ›å»ºæ—¥æœŸ**: 2025-01-27  

---

## ğŸ“‹ ç›®å½•

- [1. åŸºç¡€è®¾æ–½å±‚æ¦‚è¿°](#1-åŸºç¡€è®¾æ–½å±‚æ¦‚è¿°)
- [2. æ··åˆæ¶æ„ä¸‹çš„åŠŸèƒ½ç»„ä»¶è¦æ±‚](#2-æ··åˆæ¶æ„ä¸‹çš„åŠŸèƒ½ç»„ä»¶è¦æ±‚)
- [3. æ ¸å¿ƒç»„ä»¶](#3-æ ¸å¿ƒç»„ä»¶)
- [4. é€‚é…å™¨æ¨¡å¼](#4-é€‚é…å™¨æ¨¡å¼)
- [5. äº‹ä»¶å­˜å‚¨](#5-äº‹ä»¶å­˜å‚¨)
- [6. å®ç°æŒ‡å—](#6-å®ç°æŒ‡å—)
- [7. æœ€ä½³å®è·µ](#7-æœ€ä½³å®è·µ)

---

## 1. åŸºç¡€è®¾æ–½å±‚æ¦‚è¿°

### 1.1 å®šä¹‰

åŸºç¡€è®¾æ–½å±‚æä¾›æŠ€æœ¯å®ç°ï¼Œæ”¯æŒä¸Šå±‚æ¶æ„çš„è¿è¡Œã€‚å®ƒå®ç°é¢†åŸŸå±‚å®šä¹‰çš„æ¥å£ï¼Œè¿æ¥å¤–éƒ¨ç³»ç»Ÿå’ŒæœåŠ¡ã€‚

### 1.2 èŒè´£

```
åŸºç¡€è®¾æ–½å±‚èŒè´£
â”œâ”€â”€ 1. å®ç°ä»“å‚¨æ¥å£
â”‚   â”œâ”€â”€ æ•°æ®åº“è®¿é—®
â”‚   â”œâ”€â”€ æ•°æ®æ˜ å°„
â”‚   â”œâ”€â”€ æŸ¥è¯¢ä¼˜åŒ–
â”‚   â””â”€â”€ äº‹åŠ¡ç®¡ç†
â”‚
â”œâ”€â”€ 2. å®ç°ç«¯å£é€‚é…å™¨
â”‚   â”œâ”€â”€ ç¼“å­˜é€‚é…å™¨
â”‚   â”œâ”€â”€ æ¶ˆæ¯é˜Ÿåˆ—é€‚é…å™¨
â”‚   â”œâ”€â”€ å¤–éƒ¨æœåŠ¡é€‚é…å™¨
â”‚   â””â”€â”€ æ–‡ä»¶å­˜å‚¨é€‚é…å™¨
â”‚
â”œâ”€â”€ 3. äº‹ä»¶åŸºç¡€è®¾æ–½
â”‚   â”œâ”€â”€ äº‹ä»¶å­˜å‚¨å®ç°
â”‚   â”œâ”€â”€ å¿«ç…§å­˜å‚¨å®ç°
â”‚   â”œâ”€â”€ äº‹ä»¶åºåˆ—åŒ–
â”‚   â””â”€â”€ äº‹ä»¶ç‰ˆæœ¬ç®¡ç†
â”‚
â””â”€â”€ 4. æŠ€æœ¯æœåŠ¡
    â”œâ”€â”€ æ—¥å¿—æœåŠ¡
    â”œâ”€â”€ é…ç½®æœåŠ¡
    â”œâ”€â”€ ç›‘æ§æœåŠ¡
    â””â”€â”€ æ€§èƒ½ä¼˜åŒ–
```

### 1.3 ç‰¹ç‚¹

- **æŠ€æœ¯å®ç°**ï¼šåŒ…å«æ‰€æœ‰æŠ€æœ¯ç»†èŠ‚
- **å¯æ›¿æ¢**ï¼šå®ç°å¯ä»¥æ›¿æ¢è€Œä¸å½±å“ä¸šåŠ¡é€»è¾‘
- **é€‚é…å¤–éƒ¨**ï¼šé€‚é…å„ç§å¤–éƒ¨ç³»ç»Ÿå’ŒæœåŠ¡
- **æ€§èƒ½ä¼˜åŒ–**ï¼šè´Ÿè´£æ€§èƒ½ä¼˜åŒ–å’Œèµ„æºç®¡ç†

---

## 2. æ··åˆæ¶æ„ä¸‹çš„åŠŸèƒ½ç»„ä»¶è¦æ±‚

### 2.1 æ¦‚è¿°

åœ¨ **Clean Architecture + DDD + CQRS + Event Sourcing + Event-Driven Architecture** æ··åˆæ¶æ„æ¨¡å¼ä¸‹ï¼ŒåŸºç¡€è®¾æ–½å±‚éœ€è¦å®ç°é¢†åŸŸå±‚å’Œåº”ç”¨å±‚å®šä¹‰çš„æ‰€æœ‰æ¥å£ï¼Œå¹¶æä¾›å¯¹ CQRSã€ESã€EDA çš„å®Œæ•´æŠ€æœ¯æ”¯æŒã€‚

### 2.2 æ¶æ„æ¨¡å¼å¯¹åŸºç¡€è®¾æ–½å±‚çš„è¦æ±‚

#### 2.2.1 Clean Architecture è¦æ±‚

```
Clean Architecture å¯¹åŸºç¡€è®¾æ–½å±‚çš„è¦æ±‚ï¼š
â”œâ”€â”€ âœ… å®ç°é¢†åŸŸå±‚æ¥å£
â”‚   â””â”€â”€ ä»“å‚¨æ¥å£ã€é¢†åŸŸæœåŠ¡æ¥å£
â”‚
â”œâ”€â”€ âœ… å®ç°åº”ç”¨å±‚ç«¯å£
â”‚   â””â”€â”€ è¾“å‡ºç«¯å£çš„å…·ä½“å®ç°
â”‚
â”œâ”€â”€ âœ… é€‚é…å™¨æ¨¡å¼
â”‚   â””â”€â”€ é€‚é…å¤–éƒ¨ç³»ç»Ÿï¼Œéš”ç¦»æŠ€æœ¯ç»†èŠ‚
â”‚
â””â”€â”€ âœ… å¯æ›¿æ¢æ€§
    â””â”€â”€ æŠ€æœ¯å®ç°å¯ä»¥æ›¿æ¢è€Œä¸å½±å“ä¸šåŠ¡é€»è¾‘
```

#### 2.2.2 DDD è¦æ±‚

```
DDD å¯¹åŸºç¡€è®¾æ–½å±‚çš„è¦æ±‚ï¼š
â”œâ”€â”€ âœ… ä»“å‚¨å®ç°
â”‚   â”œâ”€â”€ å®ç° IRepository æ¥å£
â”‚   â”œâ”€â”€ æ•°æ®æ¨¡å‹æ˜ å°„ï¼ˆMapperï¼‰
â”‚   â”œâ”€â”€ ä¹è§‚é”å®ç°
â”‚   â””â”€â”€ äº‹åŠ¡ç®¡ç†
â”‚
â”œâ”€â”€ âœ… é¢†åŸŸäº‹ä»¶åŸºç¡€è®¾æ–½
â”‚   â”œâ”€â”€ äº‹ä»¶å‘å¸ƒæœºåˆ¶
â”‚   â”œâ”€â”€ äº‹ä»¶è®¢é˜…ç®¡ç†
â”‚   â””â”€â”€ äº‹ä»¶æŒä¹…åŒ–
â”‚
â””â”€â”€ âœ… é˜²è…å±‚å®ç°
    â””â”€â”€ é€‚é…å¤–éƒ¨ç³»ç»Ÿï¼Œä¿æŠ¤é¢†åŸŸæ¨¡å‹
```

#### 2.2.3 CQRS è¦æ±‚

```
CQRS å¯¹åŸºç¡€è®¾æ–½å±‚çš„è¦æ±‚ï¼š
â”œâ”€â”€ âœ… å†™æ¨¡å‹ä»“å‚¨
â”‚   â”œâ”€â”€ èšåˆæ ¹æŒä¹…åŒ–
â”‚   â”œâ”€â”€ ç‰ˆæœ¬æ§åˆ¶
â”‚   â””â”€â”€ äº‹åŠ¡ç®¡ç†
â”‚
â”œâ”€â”€ âœ… è¯»æ¨¡å‹ä»“å‚¨
â”‚   â”œâ”€â”€ ä¼˜åŒ–çš„æŸ¥è¯¢ç»“æ„
â”‚   â”œâ”€â”€ å»è§„èŒƒåŒ–æ•°æ®
â”‚   â”œâ”€â”€ ç¼“å­˜é›†æˆ
â”‚   â””â”€â”€ ç´¢å¼•ä¼˜åŒ–
â”‚
â”œâ”€â”€ âœ… è¯»å†™æ¨¡å‹åŒæ­¥
â”‚   â”œâ”€â”€ äº‹ä»¶æŠ•å½±å™¨åŸºç¡€è®¾æ–½
â”‚   â”œâ”€â”€ è¯»æ¨¡å‹æ›´æ–°æœºåˆ¶
â”‚   â””â”€â”€ æœ€ç»ˆä¸€è‡´æ€§ä¿è¯
â”‚
â””â”€â”€ âœ… ç¼“å­˜åŸºç¡€è®¾æ–½
    â”œâ”€â”€ æŸ¥è¯¢ç»“æœç¼“å­˜
    â”œâ”€â”€ ç¼“å­˜å¤±æ•ˆç­–ç•¥
    â””â”€â”€ åˆ†å¸ƒå¼ç¼“å­˜æ”¯æŒ
```

#### 2.2.4 Event Sourcing è¦æ±‚

```
Event Sourcing å¯¹åŸºç¡€è®¾æ–½å±‚çš„è¦æ±‚ï¼š
â”œâ”€â”€ âœ… äº‹ä»¶å­˜å‚¨å®ç°
â”‚   â”œâ”€â”€ EventStore æ¥å£å®ç°
â”‚   â”œâ”€â”€ äº‹ä»¶è¡¨è®¾è®¡ï¼ˆaggregateId, version, eventType, eventDataï¼‰
â”‚   â”œâ”€â”€ äº‹ä»¶è¿½åŠ ï¼ˆAppend-Onlyï¼‰
â”‚   â”œâ”€â”€ ç‰ˆæœ¬æ§åˆ¶å’Œå¹¶å‘å†²çªæ£€æµ‹
â”‚   â””â”€â”€ äº‹ä»¶æŸ¥è¯¢ä¼˜åŒ–ï¼ˆç´¢å¼•ã€åˆ†ç‰‡ï¼‰
â”‚
â”œâ”€â”€ âœ… å¿«ç…§å­˜å‚¨å®ç°
â”‚   â”œâ”€â”€ SnapshotStore æ¥å£å®ç°
â”‚   â”œâ”€â”€ å¿«ç…§è¡¨è®¾è®¡
â”‚   â”œâ”€â”€ å¿«ç…§åˆ›å»ºç­–ç•¥
â”‚   â”œâ”€â”€ å¿«ç…§æ¸…ç†ç­–ç•¥
â”‚   â””â”€â”€ å¿«ç…§+å¢é‡äº‹ä»¶åŠ è½½ä¼˜åŒ–
â”‚
â”œâ”€â”€ âœ… äº‹ä»¶åºåˆ—åŒ–
â”‚   â”œâ”€â”€ äº‹ä»¶åºåˆ—åŒ–å™¨å®ç°
â”‚   â”œâ”€â”€ æ”¯æŒ JSON åºåˆ—åŒ–
â”‚   â”œâ”€â”€ æ”¯æŒäº‹ä»¶ç‰ˆæœ¬ç®¡ç†
â”‚   â”œâ”€â”€ äº‹ä»¶ç±»å‹æ³¨å†Œè¡¨
â”‚   â””â”€â”€ ååºåˆ—åŒ–å·¥å‚
â”‚
â”œâ”€â”€ âœ… äº‹ä»¶æŠ•å½±åŸºç¡€è®¾æ–½
â”‚   â”œâ”€â”€ æŠ•å½±å™¨æ‰§è¡Œå¼•æ“
â”‚   â”œâ”€â”€ æŠ•å½±è¿›åº¦è¿½è¸ª
â”‚   â”œâ”€â”€ è¯»æ¨¡å‹é‡å»ºæ”¯æŒ
â”‚   â””â”€â”€ æŠ•å½±å¤±è´¥æ¢å¤
â”‚
â””â”€â”€ âœ… æ€§èƒ½ä¼˜åŒ–
    â”œâ”€â”€ äº‹ä»¶æµåˆ†é¡µåŠ è½½
    â”œâ”€â”€ å¿«ç…§é˜ˆå€¼ç®¡ç†
    â”œâ”€â”€ äº‹ä»¶ç¼“å­˜
    â””â”€â”€ å¹¶è¡ŒæŠ•å½±å¤„ç†
```

#### 2.2.5 Event-Driven Architecture è¦æ±‚

```
Event-Driven Architecture å¯¹åŸºç¡€è®¾æ–½å±‚çš„è¦æ±‚ï¼š
â”œâ”€â”€ âœ… æ¶ˆæ¯é˜Ÿåˆ—é›†æˆ
â”‚   â”œâ”€â”€ æ¶ˆæ¯é˜Ÿåˆ—é€‚é…å™¨ï¼ˆRabbitMQã€Kafkaç­‰ï¼‰
â”‚   â”œâ”€â”€ äº‹ä»¶å‘å¸ƒåˆ°æ¶ˆæ¯é˜Ÿåˆ—
â”‚   â”œâ”€â”€ æ¶ˆæ¯æ¶ˆè´¹å’Œå¤„ç†
â”‚   â””â”€â”€ æ¶ˆæ¯ç¡®è®¤æœºåˆ¶
â”‚
â”œâ”€â”€ âœ… äº‹ä»¶æ€»çº¿åŸºç¡€è®¾æ–½
â”‚   â”œâ”€â”€ å†…å­˜äº‹ä»¶æ€»çº¿ï¼ˆå¼€å‘/æµ‹è¯•ï¼‰
â”‚   â”œâ”€â”€ åˆ†å¸ƒå¼äº‹ä»¶æ€»çº¿ï¼ˆç”Ÿäº§ï¼‰
â”‚   â”œâ”€â”€ äº‹ä»¶è·¯ç”±
â”‚   â””â”€â”€ äº‹ä»¶è¿‡æ»¤
â”‚
â”œâ”€â”€ âœ… æ­»ä¿¡é˜Ÿåˆ— (DLQ)
â”‚   â”œâ”€â”€ å¤±è´¥äº‹ä»¶å­˜å‚¨
â”‚   â”œâ”€â”€ é‡è¯•æœºåˆ¶
â”‚   â”œâ”€â”€ å¤±è´¥åŸå› è®°å½•
â”‚   â””â”€â”€ æ‰‹åŠ¨æ¢å¤æ¥å£
â”‚
â”œâ”€â”€ âœ… äº‹ä»¶ç›‘æ§
â”‚   â”œâ”€â”€ äº‹ä»¶å‘å¸ƒç»Ÿè®¡
â”‚   â”œâ”€â”€ äº‹ä»¶å¤„ç†å»¶è¿Ÿç›‘æ§
â”‚   â”œâ”€â”€ å¤±è´¥ç‡ç»Ÿè®¡
â”‚   â”œâ”€â”€ æ€§èƒ½æŒ‡æ ‡æ”¶é›†
â”‚   â””â”€â”€ ç›‘æ§å‘Šè­¦
â”‚
â””â”€â”€ âœ… å¼‚æ­¥å¤„ç†åŸºç¡€è®¾æ–½
    â”œâ”€â”€ æ¶ˆæ¯ç¡®è®¤æœºåˆ¶
    â”œâ”€â”€ é‡è¯•ç­–ç•¥é…ç½®
    â”œâ”€â”€ å¹‚ç­‰æ€§ä¿è¯
    â””â”€â”€ é¡ºåºä¿è¯ï¼ˆåŒä¸€èšåˆçš„äº‹ä»¶ï¼‰
```

### 2.3 åŸºç¡€è®¾æ–½å±‚åŠŸèƒ½ç»„ä»¶å®Œæ•´æ¸…å•

åŸºäºæ··åˆæ¶æ„çš„è¦æ±‚ï¼ŒåŸºç¡€è®¾æ–½å±‚å¿…é¡»æä¾›ä»¥ä¸‹åŠŸèƒ½ç»„ä»¶ï¼š

#### å¿…éœ€ç»„ä»¶ (Must Have)

| ç»„ä»¶ | ç”¨é€” | æ”¯æŒçš„æ¨¡å¼ |
|------|------|-----------|
| **Repository å®ç°** | ä»“å‚¨æ¥å£å®ç° | Clean Architecture, DDD |
| **Database Adapter** | æ•°æ®åº“é€‚é…å™¨ | Clean Architecture |
| **Mapper** | æ•°æ®æ¨¡å‹æ˜ å°„å™¨ | DDD |
| **Transaction Manager** | äº‹åŠ¡ç®¡ç†å™¨ | DDD |

#### CQRS ç‰¹å®šç»„ä»¶

| ç»„ä»¶ | ç”¨é€” | è¯´æ˜ |
|------|------|------|
| **Write Repository** | å†™æ¨¡å‹ä»“å‚¨ | èšåˆæ ¹æŒä¹…åŒ– |
| **Read Model Repository** | è¯»æ¨¡å‹ä»“å‚¨ | æŸ¥è¯¢æ•°æ®è®¿é—® |
| **Cache Adapter** | ç¼“å­˜é€‚é…å™¨ | æŸ¥è¯¢ç»“æœç¼“å­˜ |
| **Projector Executor** | æŠ•å½±å™¨æ‰§è¡Œå™¨ | æ›´æ–°è¯»æ¨¡å‹ |

#### Event Sourcing ç‰¹å®šç»„ä»¶

| ç»„ä»¶ | ç”¨é€” | è¯´æ˜ |
|------|------|------|
| **EventStore Implementation** | äº‹ä»¶å­˜å‚¨å®ç° | æŒä¹…åŒ–äº‹ä»¶æµ |
| **SnapshotStore Implementation** | å¿«ç…§å­˜å‚¨å®ç° | æŒä¹…åŒ–èšåˆå¿«ç…§ |
| **EventSerializer** | äº‹ä»¶åºåˆ—åŒ–å™¨ | åºåˆ—åŒ–/ååºåˆ—åŒ–äº‹ä»¶ |
| **EventRegistry** | äº‹ä»¶ç±»å‹æ³¨å†Œè¡¨ | äº‹ä»¶ç±»å‹æ˜ å°„ |
| **SnapshotStrategy** | å¿«ç…§ç­–ç•¥ | å¿«ç…§åˆ›å»ºè§„åˆ™ |

#### Event-Driven Architecture ç‰¹å®šç»„ä»¶

| ç»„ä»¶ | ç”¨é€” | è¯´æ˜ |
|------|------|------|
| **MessageQueue Adapter** | æ¶ˆæ¯é˜Ÿåˆ—é€‚é…å™¨ | RabbitMQ/Kafka é›†æˆ |
| **DeadLetterQueue** | æ­»ä¿¡é˜Ÿåˆ— | å¤±è´¥äº‹ä»¶å¤„ç† |
| **EventMonitor** | äº‹ä»¶ç›‘æ§å™¨ | ç›‘æ§äº‹ä»¶å¤„ç† |
| **RetryPolicy** | é‡è¯•ç­–ç•¥ | å¤±è´¥é‡è¯•é…ç½® |
| **IdempotencyChecker** | å¹‚ç­‰æ€§æ£€æŸ¥å™¨ | é˜²æ­¢é‡å¤å¤„ç† |

---

## 3. æ ¸å¿ƒç»„ä»¶

### 3.1 ä»“å‚¨å®ç°

#### ä»“å‚¨æ¥å£ï¼ˆé¢†åŸŸå±‚å®šä¹‰ï¼‰

```typescript
// domain/repositories/user-repository.interface.ts
export interface IUserRepository {
  save(user: UserAggregate): Promise<void>;
  findById(id: EntityId): Promise<UserAggregate | null>;
  findByEmail(email: Email): Promise<UserAggregate | null>;
  findAll(criteria?: FindCriteria): Promise<UserAggregate[]>;
  delete(id: EntityId): Promise<void>;
}
```

#### ä»“å‚¨å®ç°ï¼ˆåŸºç¡€è®¾æ–½å±‚ï¼‰

```typescript
// infrastructure/repositories/user.repository.ts
import { Injectable } from '@nestjs/common';
import { IUserRepository } from '../../domain/repositories/user-repository.interface';
import { UserAggregate } from '../../domain/aggregates/user.aggregate';
import { DatabaseService } from '@hl8/database';

@Injectable()
export class UserRepository implements IUserRepository {
  constructor(
    private readonly db: DatabaseService,
    private readonly mapper: UserMapper
  ) {}

  async save(user: UserAggregate): Promise<void> {
    // 1. æ˜ å°„èšåˆæ ¹åˆ°æ•°æ®æ¨¡å‹
    const dataModel = this.mapper.toDataModel(user);
    
    // 2. æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
    const existing = await this.db.users.findOne({ id: dataModel.id });
    
    // 3. æ’å…¥æˆ–æ›´æ–°
    if (existing) {
      await this.db.users.update(
        { id: dataModel.id },
        dataModel,
        { version: user.version - 1 }  // ä¹è§‚é”
      );
    } else {
      await this.db.users.insert(dataModel);
    }
  }

  async findById(id: EntityId): Promise<UserAggregate | null> {
    // 1. æŸ¥è¯¢æ•°æ®åº“
    const dataModel = await this.db.users.findOne({ id: id.toString() });
    if (!dataModel) {
      return null;
    }
    
    // 2. æ˜ å°„ä¸ºèšåˆæ ¹
    return this.mapper.toDomain(dataModel);
  }

  async findByEmail(email: Email): Promise<UserAggregate | null> {
    const dataModel = await this.db.users.findOne({ email: email.value });
    if (!dataModel) {
      return null;
    }
    return this.mapper.toDomain(dataModel);
  }

  async findAll(criteria?: FindCriteria): Promise<UserAggregate[]> {
    const dataModels = await this.db.users.find(criteria);
    return dataModels.map(dm => this.mapper.toDomain(dm));
  }

  async delete(id: EntityId): Promise<void> {
    await this.db.users.softDelete({ id: id.toString() });
  }
}
```

### 3.2 é€‚é…å™¨

#### ç¼“å­˜é€‚é…å™¨

```typescript
/**
 * ç¼“å­˜é€‚é…å™¨æ¥å£
 */
export interface ICacheAdapter {
  get<T>(key: string): Promise<T | null>;
  set<T>(key: string, value: T, ttl?: number): Promise<void>;
  delete(key: string): Promise<void>;
  clear(pattern?: string): Promise<void>;
}

/**
 * Redis ç¼“å­˜é€‚é…å™¨å®ç°
 */
@Injectable()
export class RedisCacheAdapter implements ICacheAdapter {
  constructor(
    @Inject('REDIS_CLIENT') private readonly redis: RedisClient
  ) {}

  async get<T>(key: string): Promise<T | null> {
    const value = await this.redis.get(key);
    if (!value) return null;
    return JSON.parse(value);
  }

  async set<T>(key: string, value: T, ttl = 300): Promise<void> {
    await this.redis.setex(key, ttl, JSON.stringify(value));
  }

  async delete(key: string): Promise<void> {
    await this.redis.del(key);
  }

  async clear(pattern?: string): Promise<void> {
    const keys = await this.redis.keys(pattern || '*');
    if (keys.length > 0) {
      await this.redis.del(...keys);
    }
  }
}
```

#### æ¶ˆæ¯é˜Ÿåˆ—é€‚é…å™¨

```typescript
/**
 * æ¶ˆæ¯é˜Ÿåˆ—é€‚é…å™¨æ¥å£
 */
export interface IMessageQueueAdapter {
  publish(topic: string, message: unknown): Promise<void>;
  subscribe(topic: string, handler: MessageHandler): Promise<void>;
  unsubscribe(topic: string): Promise<void>;
}

/**
 * RabbitMQ é€‚é…å™¨å®ç°
 */
@Injectable()
export class RabbitMQAdapter implements IMessageQueueAdapter {
  constructor(
    @Inject('RABBITMQ_CLIENT') private readonly client: RabbitMQClient
  ) {}

  async publish(topic: string, message: unknown): Promise<void> {
    await this.client.publish(topic, Buffer.from(JSON.stringify(message)));
  }

  async subscribe(topic: string, handler: MessageHandler): Promise<void> {
    await this.client.subscribe(topic, async (msg) => {
      const message = JSON.parse(msg.content.toString());
      await handler(message);
    });
  }

  async unsubscribe(topic: string): Promise<void> {
    await this.client.unsubscribe(topic);
  }
}
```

---

## 4. é€‚é…å™¨æ¨¡å¼

### 4.1 ç«¯å£é€‚é…å™¨æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Ports & Adapters Pattern                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                     â”‚
â”‚  Application Layer                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚     Use Cases & Services          â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚           â”‚                  â”‚                      â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚     â”‚  Output   â”‚      â”‚  Output   â”‚              â”‚
â”‚     â”‚  Port     â”‚      â”‚  Port     â”‚              â”‚
â”‚     â”‚(Interface)â”‚      â”‚(Interface)â”‚              â”‚
â”‚     â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚           â”‚                  â”‚                      â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• â”‚
â”‚           â”‚ Infrastructure   â”‚                      â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚     â”‚  Adapter  â”‚      â”‚  Adapter  â”‚              â”‚
â”‚     â”‚ (Database)â”‚      â”‚  (Cache)  â”‚              â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2 ç«¯å£å®šä¹‰ï¼ˆåº”ç”¨å±‚ï¼‰

```typescript
// application/ports/repository.port.ts
export interface IRepositoryPort<T> {
  save(entity: T): Promise<void>;
  findById(id: string): Promise<T | null>;
}

// application/ports/cache.port.ts
export interface ICachePort {
  get<T>(key: string): Promise<T | null>;
  set<T>(key: string, value: T, ttl?: number): Promise<void>;
}

// application/ports/event-publisher.port.ts
export interface IEventPublisherPort {
  publish(event: DomainEvent): Promise<void>;
  publishAll(events: DomainEvent[]): Promise<void>;
}
```

### 4.3 é€‚é…å™¨å®ç°ï¼ˆåŸºç¡€è®¾æ–½å±‚ï¼‰

```typescript
// infrastructure/adapters/repository.adapter.ts
@Injectable()
export class RepositoryAdapter<T> implements IRepositoryPort<T> {
  constructor(
    private readonly db: DatabaseService,
    private readonly mapper: IMapper<T, DataModel>
  ) {}

  async save(entity: T): Promise<void> {
    const dataModel = this.mapper.toDataModel(entity);
    await this.db.save(dataModel);
  }

  async findById(id: string): Promise<T | null> {
    const dataModel = await this.db.findById(id);
    if (!dataModel) return null;
    return this.mapper.toDomain(dataModel);
  }
}
```

---

## 5. äº‹ä»¶å­˜å‚¨

### 5.1 äº‹ä»¶å­˜å‚¨æ¥å£

```typescript
/**
 * äº‹ä»¶å­˜å‚¨æ¥å£
 */
export interface IEventStore {
  /**
   * ä¿å­˜äº‹ä»¶
   */
  saveEvents(
    aggregateId: string,
    events: DomainEvent[],
    expectedVersion?: number
  ): Promise<void>;

  /**
   * è·å–äº‹ä»¶æµ
   */
  getEvents(
    aggregateId: string,
    fromVersion?: number
  ): Promise<DomainEvent[]>;

  /**
   * è·å–æ‰€æœ‰äº‹ä»¶
   */
  getAllEvents(
    fromTimestamp?: Date,
    toTimestamp?: Date
  ): Promise<DomainEvent[]>;
}
```

### 5.2 äº‹ä»¶å­˜å‚¨å®ç°

```typescript
@Injectable()
export class EventStore implements IEventStore {
  constructor(
    private readonly db: DatabaseService,
    private readonly eventSerializer: IEventSerializer
  ) {}

  async saveEvents(
    aggregateId: string,
    events: DomainEvent[],
    expectedVersion?: number
  ): Promise<void> {
    // 1. æ£€æŸ¥ç‰ˆæœ¬å†²çª
    if (expectedVersion !== undefined) {
      const currentVersion = await this.getCurrentVersion(aggregateId);
      if (currentVersion !== expectedVersion) {
        throw new ConcurrencyError('Version conflict detected');
      }
    }

    // 2. åºåˆ—åŒ–äº‹ä»¶
    const eventRecords = events.map((event, index) => ({
      eventId: event.eventId.toString(),
      aggregateId: aggregateId,
      eventType: event.eventType,
      eventData: this.eventSerializer.serialize(event),
      version: (expectedVersion || 0) + index + 1,
      occurredOn: event.occurredOn,
      metadata: event.metadata,
    }));

    // 3. ä¿å­˜åˆ°æ•°æ®åº“
    await this.db.eventStore.insertMany(eventRecords);
  }

  async getEvents(
    aggregateId: string,
    fromVersion = 0
  ): Promise<DomainEvent[]> {
    // 1. æŸ¥è¯¢äº‹ä»¶è®°å½•
    const records = await this.db.eventStore.find({
      aggregateId,
      version: { $gt: fromVersion },
    }).sort({ version: 1 });

    // 2. ååºåˆ—åŒ–äº‹ä»¶
    return records.map(record => 
      this.eventSerializer.deserialize(record.eventType, record.eventData)
    );
  }

  async getAllEvents(
    fromTimestamp?: Date,
    toTimestamp?: Date
  ): Promise<DomainEvent[]> {
    const query: any = {};
    if (fromTimestamp) {
      query.occurredOn = { $gte: fromTimestamp };
    }
    if (toTimestamp) {
      query.occurredOn = { ...query.occurredOn, $lte: toTimestamp };
    }

    const records = await this.db.eventStore.find(query).sort({ occurredOn: 1 });
    return records.map(record =>
      this.eventSerializer.deserialize(record.eventType, record.eventData)
    );
  }

  private async getCurrentVersion(aggregateId: string): Promise<number> {
    const lastEvent = await this.db.eventStore.findOne(
      { aggregateId },
      { sort: { version: -1 } }
    );
    return lastEvent?.version || 0;
  }
}
```

### 5.3 å¿«ç…§å­˜å‚¨

```typescript
/**
 * å¿«ç…§å­˜å‚¨æ¥å£
 */
export interface ISnapshotStore {
  saveSnapshot(snapshot: IAggregateSnapshot): Promise<void>;
  getSnapshot(aggregateId: string): Promise<IAggregateSnapshot | null>;
  deleteSnapshot(aggregateId: string): Promise<void>;
}

/**
 * å¿«ç…§å­˜å‚¨å®ç°
 */
@Injectable()
export class SnapshotStore implements ISnapshotStore {
  constructor(
    private readonly db: DatabaseService
  ) {}

  async saveSnapshot(snapshot: IAggregateSnapshot): Promise<void> {
    await this.db.snapshots.upsert(
      { aggregateId: snapshot.aggregateId },
      {
        aggregateId: snapshot.aggregateId,
        aggregateType: snapshot.aggregateType,
        version: snapshot.version,
        state: snapshot.state,
        createdAt: snapshot.createdAt,
      }
    );
  }

  async getSnapshot(aggregateId: string): Promise<IAggregateSnapshot | null> {
    return await this.db.snapshots.findOne({ aggregateId });
  }

  async deleteSnapshot(aggregateId: string): Promise<void> {
    await this.db.snapshots.delete({ aggregateId });
  }
}
```

---

## 6. å®ç°æŒ‡å—

### 6.1 ä»“å‚¨å®ç°æ­¥éª¤

```typescript
// æ­¥éª¤ 1: å®šä¹‰æ•°æ®æ¨¡å‹
interface UserDataModel {
  id: string;
  name: string;
  email: string;
  status: string;
  version: number;
  createdAt: Date;
  updatedAt: Date;
  tenantId: string;
}

// æ­¥éª¤ 2: åˆ›å»ºæ˜ å°„å™¨
class UserMapper {
  toDomain(dataModel: UserDataModel): UserAggregate {
    const email = Email.create(dataModel.email);
    const user = User.create(dataModel.name, email, dataModel.tenantId);
    return UserAggregate.fromUser(user, dataModel.version);
  }

  toDataModel(aggregate: UserAggregate): UserDataModel {
    return {
      id: aggregate.id.toString(),
      name: aggregate.user.name,
      email: aggregate.user.email.value,
      status: aggregate.user.status,
      version: aggregate.version,
      createdAt: aggregate.createdAt,
      updatedAt: aggregate.updatedAt,
      tenantId: aggregate.tenantId,
    };
  }
}

// æ­¥éª¤ 3: å®ç°ä»“å‚¨
@Injectable()
export class UserRepository implements IUserRepository {
  constructor(
    private readonly db: DatabaseService,
    private readonly mapper: UserMapper
  ) {}

  async save(user: UserAggregate): Promise<void> {
    const dataModel = this.mapper.toDataModel(user);
    await this.db.users.save(dataModel);
  }

  async findById(id: EntityId): Promise<UserAggregate | null> {
    const dataModel = await this.db.users.findOne({ id: id.toString() });
    if (!dataModel) return null;
    return this.mapper.toDomain(dataModel);
  }
}
```

### 6.2 äº‹ä»¶å­˜å‚¨å®ç°æ­¥éª¤

```typescript
// æ­¥éª¤ 1: å®šä¹‰äº‹ä»¶è®°å½•æ¨¡å‹
interface EventRecord {
  eventId: string;
  aggregateId: string;
  aggregateType: string;
  eventType: string;
  eventData: string;  // JSON åºåˆ—åŒ–
  version: number;
  occurredOn: Date;
  metadata?: Record<string, unknown>;
}

// æ­¥éª¤ 2: å®ç°äº‹ä»¶åºåˆ—åŒ–å™¨
class EventSerializer implements IEventSerializer {
  serialize(event: DomainEvent): string {
    return JSON.stringify({
      eventType: event.eventType,
      eventData: event.eventData,
      aggregateId: event.aggregateId.toString(),
      version: event.version,
      occurredOn: event.occurredOn,
    });
  }

  deserialize(eventType: string, data: string): DomainEvent {
    const parsed = JSON.parse(data);
    const EventClass = this.getEventClass(eventType);
    return new EventClass(parsed);
  }

  private getEventClass(eventType: string): any {
    // äº‹ä»¶ç±»å‹æ˜ å°„
    const eventClassMap = {
      'UserCreated': UserCreatedEvent,
      'UserEmailUpdated': UserEmailUpdatedEvent,
      // ...
    };
    return eventClassMap[eventType];
  }
}

// æ­¥éª¤ 3: å®ç°äº‹ä»¶å­˜å‚¨
@Injectable()
export class EventStore implements IEventStore {
  async saveEvents(
    aggregateId: string,
    events: DomainEvent[],
    expectedVersion?: number
  ): Promise<void> {
    // æ£€æŸ¥ç‰ˆæœ¬å†²çª
    // åºåˆ—åŒ–å¹¶ä¿å­˜äº‹ä»¶
    // æ›´æ–°èšåˆç‰ˆæœ¬
  }

  async getEvents(
    aggregateId: string,
    fromVersion = 0
  ): Promise<DomainEvent[]> {
    // æŸ¥è¯¢äº‹ä»¶è®°å½•
    // ååºåˆ—åŒ–ä¸ºäº‹ä»¶å¯¹è±¡
    // æŒ‰ç‰ˆæœ¬æ’åºè¿”å›
  }
}
```

---

## 7. æœ€ä½³å®è·µ

### 7.1 ä»“å‚¨å®ç°æœ€ä½³å®è·µ

#### âœ… DO - åº”è¯¥åšçš„

1. **ä½¿ç”¨æ˜ å°„å™¨åˆ†ç¦»å…³æ³¨ç‚¹**

   ```typescript
   // âœ… å¥½çš„åšæ³•
   class UserRepository {
     constructor(
       private readonly db: DatabaseService,
       private readonly mapper: UserMapper  // ä¸“é—¨çš„æ˜ å°„å™¨
     ) {}
   }
   ```

2. **å®ç°ä¹è§‚é”**

   ```typescript
   async save(aggregate: AggregateRoot): Promise<void> {
     const expectedVersion = aggregate.version - 1;
     const result = await this.db.update(
       { id: aggregate.id, version: expectedVersion },
       { ...data, version: aggregate.version }
     );
     
     if (result.modifiedCount === 0) {
       throw new ConcurrencyError('Version conflict');
     }
   }
   ```

3. **ä½¿ç”¨å·¥ä½œå•å…ƒæ¨¡å¼**

   ```typescript
   class UnitOfWork {
     private aggregates = new Map<string, AggregateRoot>();
     
     register(aggregate: AggregateRoot): void {
       this.aggregates.set(aggregate.id.toString(), aggregate);
     }
     
     async commit(): Promise<void> {
       for (const aggregate of this.aggregates.values()) {
         await this.repository.save(aggregate);
       }
       this.aggregates.clear();
     }
   }
   ```

#### âŒ DON'T - ä¸åº”è¯¥åšçš„

1. **ä¸è¦åœ¨ä»“å‚¨ä¸­åŒ…å«ä¸šåŠ¡é€»è¾‘**

   ```typescript
   // âŒ ä¸è¦è¿™æ ·
   async save(user: User): Promise<void> {
     if (user.age < 18) {  // ä¸šåŠ¡é€»è¾‘åº”è¯¥åœ¨é¢†åŸŸå±‚
       throw new Error('User must be 18+');
     }
     await this.db.save(user);
   }
   ```

2. **ä¸è¦æš´éœ²æ•°æ®æ¨¡å‹**

   ```typescript
   // âŒ ä¸è¦è¿™æ ·
   async findById(id: string): Promise<UserDataModel> {
     return await this.db.users.findOne({ id });  // æš´éœ²äº†æ•°æ®æ¨¡å‹
   }
   
   // âœ… åº”è¯¥è¿™æ ·
   async findById(id: EntityId): Promise<UserAggregate | null> {
     const dataModel = await this.db.users.findOne({ id: id.toString() });
     return dataModel ? this.mapper.toDomain(dataModel) : null;
   }
   ```

### 7.2 é€‚é…å™¨å®ç°æœ€ä½³å®è·µ

#### âœ… DO - åº”è¯¥åšçš„

1. **å®ç°é‡è¯•æœºåˆ¶**

   ```typescript
   class ResilientAdapter implements IExternalServiceAdapter {
     async call(params: Params): Promise<Result> {
       return await this.retry(
         () => this.externalService.call(params),
         { maxRetries: 3, delay: 1000 }
       );
     }
   }
   ```

2. **æ·»åŠ ç›‘æ§å’Œæ—¥å¿—**

   ```typescript
   class MonitoredAdapter implements IAdapter {
     async execute(params: Params): Promise<Result> {
       const start = Date.now();
       try {
         const result = await this.delegate.execute(params);
         this.metrics.recordSuccess(Date.now() - start);
         return result;
       } catch (error) {
         this.metrics.recordFailure(Date.now() - start);
         throw error;
       }
     }
   }
   ```

3. **ä½¿ç”¨è¿æ¥æ± **

   ```typescript
   class DatabaseAdapter {
     private pool: ConnectionPool;
     
     async query(sql: string): Promise<Result> {
       const connection = await this.pool.acquire();
       try {
         return await connection.query(sql);
       } finally {
         await this.pool.release(connection);
       }
     }
   }
   ```

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [æ¶æ„æ¦‚è¿°](00-overview.md)
- [é¢†åŸŸå±‚è®¾è®¡](01-domain-layer.md)
- [æ¥å£å±‚è®¾è®¡](04-interface-layer.md)
- [äº‹ä»¶æº¯æºè®¾è®¡](06-event-sourcing.md)

---

**æ–‡æ¡£ç»´æŠ¤**: HL8 æ¶æ„å›¢é˜Ÿ  
**æœ€åæ›´æ–°**: 2025-01-27
