# 业务规则与业务逻辑的区别

这是一个非常深刻的问题，理解这两者的区别对于设计出良好的架构，尤其是在Clean Architecture中，至关重要。

简单来说：

* **业务规则是“什么”（What）和“为什么”（Why）**，是稳定的、核心的真理。
* **业务逻辑是“如何”（How）**，是易变的、实现规则的具体流程和步骤。

我们可以用一个生动的比喻来理解：

> **业务规则是国家的法律条文（例如，“禁止酒后驾车”），而业务逻辑是警察执法的整个过程（拦截车辆、询问、使用酒精测试仪、读取数据、开具罚单）。**

法律是核心规则，它本身不会改变。而执法的流程、使用的工具（从简单的观察升级到精准的仪器）可能会随着时间而变化和改进。

---

## 详细分解

### 业务规则

业务规则是领域内的核心政策和约束。它定义了**什么是对的，什么是错的，什么是被允许的，什么是不被允许的**。它通常是领域专家口中的“行话”和“规矩”。

* **核心特点**：
    1. **本质性**：是业务本身的固有部分，不依赖于任何软件系统而存在。即使公司用手工记账，这些规则依然存在。
    2. **稳定性**：不会频繁改变。一旦确立，会在很长时间内保持有效。
    3. **纯粹性**：不关心技术实现，只表达业务概念。

* **例子**：
  * “一个订单的总金额必须等于所有订单行金额之和，再减去折扣。”
  * “账户余额不能低于零。”（即不能透支）
  * “只有状态为‘已发货’的订单才能被标记为‘已完成’。”
  * “金牌客户在购买所有商品时可享受10%的折扣。”

在Clean Architecture中，**业务规则主要存在于领域层（Domain Layer）**，由**实体（Entity）** 和**领域服务（Domain Service）** 来承载。

**代码体现：**

```java
// 实体（Order）内部的一个方法，体现了“计算总金额”的业务规则。
public class Order {
    private List<OrderItem> items;
    private Money discount;

    public Money calculateTotalAmount() {
        Money total = items.stream()
                .map(OrderItem::getSubtotal)
                .reduce(Money.ZERO, Money::add);
        return total.minus(discount); // 核心规则：总价 = 商品小计之和 - 折扣
    }

    // 另一个业务规则：不能支付已取消的订单
    public void pay() {
        if (this.status == OrderStatus.CANCELLED) {
            throw new IllegalStateException("Cannot pay a cancelled order.");
        }
        this.status = OrderStatus.PAID;
    }
}
```

---

### 业务逻辑

业务逻辑是为了满足业务规则而执行的一系列**操作、步骤和决策流程**。它协调多个领域对象，并可能涉及与外部组件的交互，以完成一个特定的业务目标。

* **核心特点**：
    1. **流程性**：它描述了一个“工作流”或“配方”。
    2. **易变性**：流程可能会因为优化、新工具或新规则的出现而改变。
    3. **协调性**：它知道需要调用哪些实体、服务，并按什么顺序调用。

* **例子**：
  * “创建订单”的流程：验证用户 -> 验证库存 -> 计算价格 -> 锁定库存 -> 保存订单 -> 发送确认通知。
  * “用户注册”的流程：检查邮箱是否唯一 -> 创建用户实体 -> 发送激活邮件 -> 记录注册日志。

在Clean Architecture中，**业务逻辑主要存在于领域层（Domain Layer）**，由**实体（Entity）**、**值对象（Value Object）** 和**领域服务（Domain Service）** 来承载。**应用层包含的是用例逻辑**，即协调领域对象完成业务场景的流程，而不是业务逻辑本身。

**代码体现：**

```java
// 一个Use Case，包含了"创建订单"的用例逻辑（协调流程）
public class CreateOrderUseCase {

    private final OrderRepository orderRepository;
    private final UserRepository userRepository;
    private final InventoryService inventoryService;
    private final NotificationService notificationService;

    @Transactional
    public OrderResult execute(CreateOrderCommand command) {
        // 步骤1: 获取并验证用户（业务流程的一部分）
        User user = userRepository.findById(command.getUserId())
                .orElseThrow(() -> new UserNotFoundException());

        // 步骤2: 验证库存（业务流程的一部分）
        if (!inventoryService.isStockAvailable(command.getProductId(), command.getQuantity())) {
            throw new InsufficientStockException();
        }

        // 步骤3: 创建Order实体（此时，实体内部的业务规则会被自动触发，例如calculateTotalAmount）
        Order order = new Order(user, command.getProductId(), command.getQuantity());

        // 步骤4: 锁定库存（业务流程的一部分）
        inventoryService.lockStock(command.getProductId(), command.getQuantity());

        // 步骤5: 保存订单（业务流程的一部分）
        orderRepository.save(order);

        // 步骤6: 发送通知（业务流程的一部分）
        notificationService.sendOrderConfirmation(user.getEmail(), order);

        return new OrderResult(order.getId());
    }
}
```

---

### 用例逻辑 vs 业务逻辑

在Clean Architecture中，还有一个重要的概念需要区分：**用例逻辑**和**业务逻辑**。

#### 用例逻辑（Use Case Logic）

用例逻辑是应用层的关注点，它协调领域对象完成业务场景的流程。用例逻辑：

* **核心特点**：
    1. **协调性**：协调多个领域对象和外部服务
    2. **流程性**：描述完成业务场景的步骤顺序
    3. **无业务逻辑**：不包含具体的业务规则实现
    4. **事务边界**：管理事务边界和一致性

* **例子**：
  * 协调用户创建：验证输入 -> 创建用户实体 -> 保存到数据库 -> 发布事件
  * 协调订单处理：获取用户 -> 验证库存 -> 创建订单 -> 锁定库存 -> 发送通知

**代码体现：**

```typescript
// 应用层 - 用例逻辑（协调流程）
export class CreateUserUseCase {
  async execute(input: CreateUserInput): Promise<CreateUserOutput> {
    // 用例逻辑：协调各个组件完成业务场景
    const user = UserAggregate.create(input.email, input.username);
    
    // 委托给领域对象执行业务逻辑
    user.register(input.email, input.username, input.password);
    
    // 协调基础设施服务
    await this.userRepository.save(user);
    await this.eventBus.publishAll(user.getUncommittedEvents());
    
    return new CreateUserOutput(user.getId());
  }
}
```

#### 业务逻辑（Business Logic）

业务逻辑是领域层的关注点，它实现业务规则的具体算法和流程。业务逻辑：

* **核心特点**：
    1. **实现性**：实现具体的业务规则
    2. **算法性**：包含计算、验证、转换等算法
    3. **纯粹性**：不依赖外部服务
    4. **稳定性**：相对稳定，不会频繁变化

* **例子**：
  * 用户注册的具体实现：验证邮箱格式、加密密码、设置初始状态
  * 订单金额计算：计算商品小计、应用折扣、计算税费

**代码体现：**

```typescript
// 领域层 - 业务逻辑（具体实现）
export class User extends BaseEntity {
  // 业务逻辑：用户注册的具体实现
  public register(email: Email, username: Username, password: Password): void {
    // 业务规则：用户状态转换
    if (this._status !== UserStatus.Pending) {
      throw new UserNotPendingException('只有待激活状态的用户才能注册');
    }
    
    // 业务逻辑：注册的具体实现
    this._email = email;
    this._username = username;
    this._password = password;
    this._status = UserStatus.Active;
    this.updateTimestamp();
  }
}
```

#### 三者的关系

```text
业务规则（What/Why） → 业务逻辑（How实现） → 用例逻辑（How协调）
     ↓                    ↓                    ↓
   领域层                领域层                应用层
```

---

### 对比表格

| 特性 | 业务规则 | 业务逻辑 |
| :--- | :--- | :--- |
| **定义** | 领域的核心政策和约束 | 为实现规则而执行的步骤和流程 |
| **关注点** | **什么（What）** 是正确的状态 | **如何（How）** 达到正确状态 |
| **变化频率** | **稳定**，是业务核心 | **相对易变**，流程和工具会优化 |
| **所在架构层** | **领域层**（实体、值对象、领域服务） | **领域层**（实体、值对象、领域服务）和**应用层**（用例逻辑、协调流程） |
| **类比** | **法律条文** | **执法流程** |
| **例子** | “账户不能透支” | “从账户A转账到账户B的整个过程” |
| **技术相关性** | **纯粹**，不依赖任何技术 | **可能涉及**，如调用外部API、数据库 |

### 总结

在Clean Architecture中，区分三者至关重要：

* 你将**业务规则**放在**领域层**，让它保持纯净和稳定，这是你系统的**核心价值**。
* 你将**业务逻辑**放在**领域层**，用它来实现具体的业务规则和算法。
* 你将**用例逻辑**放在**应用层**，用它来协调领域对象和外部资源，完成具体的用户场景。

这种三层分离确保了：

1. **业务规则**的稳定性：核心业务规则不会因为技术实现的变化而改变
2. **业务逻辑**的纯粹性：业务逻辑专注于实现业务规则，不依赖外部服务
3. **用例逻辑**的灵活性：用例逻辑可以灵活地协调不同的组件来完成业务场景

当你的业务流程需要改变时（例如，增加一个新的验证步骤或更换通知方式），你只需要修改应用层的用例逻辑。当业务规则改变时（例如，折扣计算方式变了），你可以在领域层集中修改业务逻辑。这种分离最终带来了更好的**可维护性**、**可测试性**和**灵活性**。
